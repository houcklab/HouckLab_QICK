import random

from socProxy import makeProxy
import matplotlib.pyplot as plt
import numpy as np
from qick.helpers import gauss
from Experiment import ExperimentClass
import datetime
from qick import *
import time
from scipy.optimize import curve_fit
from tqdm.notebook import tqdm
import pickle
import os
import warnings
import PythonDrivers.readTempLog as tempLog

# ============================================= #
# Russell McLellan, supported by Sara Sussman and Sho Uemura
# Initial working version August 16, 2022
#
# Purpose of this program is to emulate a VNA-style frequency sweep with the RFSOC using up to four tones for faster
# averaging. Two forms of averaging are used, 'reps' and 'rounds'. Reps are repeated measurements without changing the
# frequency. Rounds are repeats of the spectrum. Note that reps are coherent averages of I and Q, while rounds average
# amplitudes only
#
# There are two classes in this file:
# ResSweepProgram - created and handled by ResSweep. This class directly interfaces with the RFSOC firmware
# ResSweep - created and handled by the user in another folder. Repackages data for ResSweepProgram, creates
#            preliminary fits, saves data, and loops through frequency points
#
# ============================================= #


class ResSweepProgram(AveragerProgram):
    def __init__(self, soccfg, cfg):
        # inputs:
        #       - cfg - python dictionary generated by ResSweep class
        #       - soccfg - object referencing the RFSOC
        super().__init__(soccfg, cfg)

    # initialize is run once when ResSweep calls ResSweepProgram.acquire
    def initialize(self):
        cfg = self.cfg

        # initialize DAC and ADC
        self.declare_gen(ch=cfg["res_ch"], nqz=1, mixer_freq=cfg["mixer_freq"], mux_freqs=cfg["pulse_freqs"],
                          mux_gains=cfg["pulse_gains"], ro_ch=cfg["ro_chs"][0])
        for iCh, ch in enumerate(cfg["ro_chs"]):  # configure the readout lengths and downconversion frequencies
            self.declare_readout(ch=ch, freq=cfg["pulse_freqs"][iCh], length=cfg["readout_length"],
                                 gen_ch=cfg["res_ch"])

        # play for ring_time
        self.set_pulse_registers(ch=cfg["res_ch"], style="const", length=cfg["ring_time_gen"], mask=[0, 1, 2, 3])
        self.synci(200)  # give processor some time to configure pulses
        self.pulse(ch=self.cfg["res_ch"], t=0)

        # reconfigure pulses for readout_length
        self.set_pulse_registers(ch=cfg["res_ch"], style="const", length=cfg["readout_length_gen"]+cfg["adc_trig_offset_gen"], mask=[0, 1, 2, 3])

        # sync everything. Ensures that ring_time pulse is over before proceeding
        self.sync_all()

    # body is run for cfg['reps'] number of times when ResSweep calls ResSweepProgram.acquire
    def body(self):
        # play pulses. Trigger for a small wait time for the pulse to sync up a bit
        self.trigger(adcs=self.ro_chs, pins=[0],
                     adc_trig_offset=self.cfg['adc_trig_offset'])  # trigger the adc acquisition
        self.pulse(ch=self.cfg["res_ch"], t=0)

        # sync everything
        self.wait_all()
        self.sync_all()

# ====================================================== #


class ResSweep(ExperimentClass):
    # this is the class that the user will interact with to take measurements
    # Two dictionaries are used throughout the class, 'input' and 'cfg'. 'Input' is entirely user defined, uses units
    # of us for time and MHz for frequency, and is not changed in any function. 'cfg' is generated by the class, uses
    # units of clock ticks for time and MHz for frequency, and is changed.
    # 'Input' is designed to be human readable, 'cfg' is for the class to interpret
    def __init__(self, inputDict=None, soc=None, soccfg=None, path='', prefix='data', config_file=None, progress=None,
                 temperatureLogPath='Z:/t1Team/logFiles/'):
        # inputs:
        #       - inputDict - Python dictionary defined by the user with fields defined
        #       - soc, soccfg - objects referring to the RFSOC proxy server
        #       - path - string specifying the path where the results will be saved
        #       - prefix - prefix attached to the beginning of the filename
        #       - tempreatureLogPath - str specifying the temperature log file that will be read for the measurement temperature
        super().__init__(soc=soc, soccfg=soccfg, path=path, prefix=prefix, cfg=None, config_file=config_file, progress=progress)

        # This value is a workaround for a problem with multiplexed readout. From Sho on Aug 12, 2022, both I and Q are
        # centered around -0.5 instead of 0. self.IQoffset is added to both I and Q as they are read to compensate.
        # This workaround should be removed when the RFSOC is patched
        self.IQoffset = 0.5

        self.soc = soc
        self.cfg = {"res_ch": 6,  # DAC channel used. This is the only one used for multiplexed output
                    "ro_chs": [i for i, res_f in enumerate(inputDict['res_f'])],  # ADC channels used. All four are used for 4x readout
                    "pulse_style": "const",  # --Fixed
                    }

        # save frequency parameters into class variables for later use
        self.LO_f = inputDict['LO_f']
        self.mixerCenter_f = inputDict['mixerCenter_f']
        self.span_f = inputDict['span_f']
        self.res_f = inputDict['res_f']

        # save number parameters for later use
        self.n_expts = inputDict['n_expts']
        self.n_rounds = inputDict['n_rounds']
        self.n_reps = inputDict['n_reps']

        # convert timing parameter for later use
        self.ring_up_time_gen = soc.us2cycles(inputDict['ring_up_time'], gen_ch=6)  # generator units. Used to set the initial pulse time
        self.ring_between_time_gen = soc.us2cycles(inputDict['ring_between_time'], gen_ch=6) # generator units. Used to set the pulse time between frequency poits
        self.cfg['readout_length'] = soc.us2cycles(inputDict['readout_length'], ro_ch=0)  # adc units. used to set the length of the readout foe each rep
        self.cfg['readout_length_gen'] = soc.us2cycles(inputDict['readout_length'], gen_ch=6)  # generator units. Used to set the length of the pulse within each rep
        self.cfg['adc_trig_offset'] = soc.us2cycles(inputDict['adc_trig_offset'])  # tProc units. Used to offset the read window from the start of each pulse in a rep
        self.cfg['adc_trig_offset_gen'] = soc.us2cycles(inputDict['adc_trig_offset'], gen_ch=6)  # generator units. Added to 'readout_length_gen' to set the length of the pulse

        # save power parameters for future use
        self.cfg["pulse_gains"] = inputDict['gain']

        # calculate frequencies to be swept. mixerArray_f is the array of mixer freqs, while pulse_freqs is the center frequency of each resonator
        self.mixerArray_f = np.linspace(self.mixerCenter_f - self.span_f / 2, self.mixerCenter_f + self.span_f / 2, self.n_expts)
        self.cfg['pulse_freqs'] = np.zeros(len(self.res_f))
        for i, f in enumerate(self.res_f):
            # this function ensures that the requested frequency is available on both the DAC and the ADC
            self.cfg['pulse_freqs'][i] = self.soc.roundfreq(f - self.LO_f - self.mixerCenter_f, dict1=self.soccfg['gens'][6],
                                                         dict2=self.soccfg['readouts'][self.cfg['ro_chs'][i]])

        # create frequency axis for each resonator. Used for plotting
        self.resArray_f = [i + self.mixerArray_f + self.LO_f for i in self.cfg['pulse_freqs']]

        # store input for saving later
        self.inputDict = inputDict

        # algorithm to increment filenumbers
        self.filePrefix = prefix
        filenames = os.listdir(self.path)
        increment = 0
        for file in filenames:
            if self.filePrefix + '_' in file:
                if '.' in file:
                    dotInd = file.index('.')
                else:
                    dotInd = 0
            try:
                newIncrement = int(file[(dotInd - 3):dotInd])
                if newIncrement > increment:
                    increment = newIncrement
            except:
                pass
        increment += 1
        self.filename = self.filePrefix + '_{0:03}'.format(increment)
        self.temperatureLogPath = temperatureLogPath
        self.readTemp()  # initial read to raise a warning if the file is out of date

        print('Pulse frequencies are: {0} MHz'.format(self.cfg['pulse_freqs']))
        print('Frequencies out are: {0} MHz'.format([i - self.LO_f for i in self.res_f]))

    # used for preliminary fits
    def hangerFit(self, xData, freq0, QInt, Qc, asymm, offset):
        Q0 = 1 / ((1 / QInt) + (1 / Qc))
        return 20 * np.log10(np.abs(1 - ((Q0 / Qc) - 2j * Q0 * asymm / (2 * np.pi * freq0)) / (
                    1 + 2j * Q0 * (xData - freq0) / freq0))) + offset

    # function to perform a frequency sweep
    def acquire(self, progress=False, debug=False):
        diList = [[] for i in self.mixerArray_f]
        dqList = [[] for i in self.mixerArray_f]
        iqListRound = [[] for i in self.mixerArray_f]
        ampArrayTMP = [np.asarray([0. for ii in self.mixerArray_f]) for i in self.res_f]
        IArray = [np.asarray([0. for ii in self.mixerArray_f]) for i in self.res_f]
        QArray = [np.asarray([0. for ii in self.mixerArray_f]) for i in self.res_f]

        start = time.time()
        for roundInd in range(self.n_rounds):
            roundStart = time.time()

            # ring up the resonator
            self.cfg['ring_time_gen'] = self.ring_up_time_gen
            self.cfg['mixer_freq'] = self.mixerArray_f[0]
            self.cfg['reps'] = 2
            prog = ResSweepProgram(self.soccfg, self.cfg)
            dummy = prog.acquire(self.soc, load_pulses=True, debug=False) # we throw out the data we collect during ring up

            # acquire sweeps of data
            self.cfg['reps'] = self.n_reps
            self.cfg['ring_time_gen'] = self.ring_between_time_gen
            for fInd, f in enumerate(tqdm(self.mixerArray_f)):
                self.cfg['mixer_freq'] = f
                # if fInd % 50 == 0:
                #     print('{0}: {1:0.2f} s'.format(fInd, time.time() - roundStart))
                # freqStart = time.time()
                prog = ResSweepProgram(self.soccfg, self.cfg)
                print(np.shape(iqListRound[fInd]))
                print(np.shape(prog.acquire(self.soc, load_pulses=True, debug=False)))

                # compensate for non-zero centered I and Q values
                for i in range(len(self.cfg['ro_chs'])):
                    iqListRound[fInd][0][i] += self.IQoffset
                    iqListRound[fInd][1][i] += self.IQoffset
                # diList[fInd] = prog.di_buf
                # dqList[fInd] = prog.dq_buf
                # print('Frequency {0}, time {1:0.3f} s'.format(fInd, time.time() - freqStart))

            # add the frequencies to older measurements
            for IQInd in range(len(self.cfg['ro_chs'])):
                for freqInd, iq in enumerate(iqListRound):
                    ampArrayTMP[IQInd][freqInd] += abs(np.asarray(iq[0][IQInd]) + 1j * np.asarray(iq[1][IQInd]))
                    IArray[IQInd][freqInd] += np.asarray(iq[0][IQInd])
                    QArray[IQInd][freqInd] += np.asarray(iq[1][IQInd])

            print('Round {0}, time {1:0.3f} s'.format(roundInd, time.time() - roundStart))

        print('Final time = {0:0.3f} s'.format(time.time() - start))

        # normalize measurements and find amplitudes
        ampArray = [i/self.n_rounds for i in ampArrayTMP]
        ampArray_log = 20*np.log10(ampArray)

        for i in range(len(self.cfg['ro_chs'])):
            IArray[i] = IArray[i]/self.n_rounds
            QArray[i] = QArray[i] / self.n_rounds

        data={'config': self.cfg,
              'inputDict': self.inputDict,
              'data': {
                  'ampArray': ampArray,
                  'ampArray_log': ampArray_log,
                  'IArray': IArray,
                  'QArray': QArray,
                  'f': self.resArray_f,
                  'power': self.inputDict['power'],
                  # 'diList': diList,
                  # 'dqList': dqList,
                  'endTime': time.time(),
                  'startTime': start,
                  'temperature_mK': self.readTemp()
              }}
        self.data=data

        return data

    # this function finds the last edited log file and reads the last temperature from it. It will throw a warning if
    # the temperature is more than 30 minutes out of date
    def readTemp(self):
        latest_edited_file = max([f for f in os.scandir(self.temperatureLogPath) if '_BFGTemps_automatedControl.txt' in f.name],
                                 key=lambda x: x.stat().st_mtime).name
        logTime, logTemp = tempLog.readTempLog(self.temperatureLogPath + '/' + latest_edited_file)
        minutesOld = (datetime.datetime.now() - logTime).total_seconds() / 60
        if minutesOld > 30:
            warnings.warn(
                'Temperature log is {0:0.01f} minutes out of date. Make sure you are outputting the log file from the temperature PC'.format(
                    minutesOld))

        return logTemp

    # call this function after acquire to plot the results with a preliminary fit
    def display(self, data=None, fit=True, **kwargs):
        if data == None:
            data = self.data
        data = data['data']

        pOpt = [[] for i in self.res_f]
        pCov = [[] for i in self.res_f]
        for i in range(len(self.cfg['ro_chs'])):
            centerF = self.resArray_f[i][data['ampArray_log'][i].argmin()]
            pOpt[i], pCov[i] = curve_fit(self.hangerFit, (self.resArray_f[i]) * 10 ** 6, data['ampArray_log'][i],
                                         p0=[(centerF) * 10 ** 6, 1e6, 1e6, 0, 0], maxfev=100000)
            pOpt[i][1] = abs(pOpt[i][1])
            pOpt[i][2] = abs(pOpt[i][2])

        if len(self.cfg['ro_chs']) == 1:
            fig, axs = plt.subplots(1, 1, figsize=(4.5, 4.5), dpi=75)
            plt.subplots_adjust(wspace=0.5, hspace=0.5)
            axs = [axs]
        elif len(self.cfg['ro_chs']) == 2:
            fig, axs = plt.subplots(2, 1, figsize=(4.5, 10), dpi=75)
            plt.subplots_adjust(wspace=0.5, hspace=0.5)
        elif len(self.cfg['ro_chs']) == 3:
            fig, axs = plt.subplots(2, 2, figsize=(10, 10), dpi=75)
            plt.subplots_adjust(wspace=0.5, hspace=0.5)
            axs[1][1].set_axis_off()
            axs[1][1].set_frame_on(False)
            axs = [axs[0][0], axs[0][1], axs[1][0]]
        elif len(self.cfg['ro_chs']) == 4:
            fig, axs = plt.subplots(2, 2, figsize=(10, 10), dpi=75)
            plt.subplots_adjust(wspace=0.5, hspace=0.5)
            axs = [axs[0][0], axs[0][1], axs[1][0], axs[1][1]]

        for i in range(len(self.cfg['ro_chs'])):
            axs[i].plot(self.resArray_f[i], data['ampArray_log'][i], '.', label='data', markersize=2)
            axs[i].plot(self.resArray_f[i], self.hangerFit((self.resArray_f[i]) * 10 ** 6, *pOpt[i]), label='fit')
            axs[i].set_ylabel('10log10(I^2 + Q^2)')
            axs[i].set_xlabel('Frequency [MHz]')
            axs[i].legend(loc='best')
            axs[i].set_title('f = {0:.0f} MHz, Q_int = {1:0.4e} , Q_c = {2:0.4e}'.format(self.res_f[i], pOpt[i][1], pOpt[i][2]))
            axs[i].grid()

        plt.savefig(self.path+'/'+self.filename+'_sweep.png', bbox_inches='tight')
        plt.show()

    # call this function after acquire to save the data
    def save_data(self, data=None):
        print(f'Saving {self.filename}')
        with open(self.path+'/'+self.filename+'.pickle', 'wb') as f:
            pickle.dump(self.data, f)
        # super().save_data(data=data['data'])

    def acquire_decimated(self, soft_avgs=1, readout_length=100, progress=False, debug=False):

        self.cfg['mixer_freq'] = self.mixerCenter_f
        self.cfg['ring_time_gen'] = self.ring_up_time_gen
        self.cfg['soft_avgs'] = soft_avgs
        self.cfg['readout_length'] = readout_length
        self.cfg['reps'] = 1

        prog = ResSweepProgram(self.soccfg, self.cfg)
        print("start decimated")
        self.soc.reset_gens()  # clear any DC or periodic values on generators
        iq_list = prog.acquire_decimated(self.soc, load_pulses=True, progress=False, debug=False)
        print("decimated done")
        data = {'config': self.cfg, 'data': {'iq_list': iq_list}}
        self.data = data
        return data

    def display_decimated(self, data=None, fit=True, **kwargs):
        if data is None:
            data = self.data

        if len(self.cfg['ro_chs']) == 1:
            fig, axs = plt.subplots(1, 1, figsize=(4.5, 4.5), dpi=75)
            axs = [axs]
            plt.subplots_adjust(wspace=0.5, hspace=0.5)
        elif len(self.cfg['ro_chs']) == 2:
            fig, axs = plt.subplots(2, 1, figsize=(4.5, 10), dpi=75)
            plt.subplots_adjust(wspace=0.5, hspace=0.5)
        elif len(self.cfg['ro_chs']) == 3:
            fig, axs = plt.subplots(2, 2, figsize=(10, 10), dpi=75)
            plt.subplots_adjust(wspace=0.5, hspace=0.5)
            axs[1][1].set_axis_off()
            axs[1][1].set_frame_on(False)
            axs = [axs[0][0], axs[0][1], axs[1][0]]
        elif len(self.cfg['ro_chs']) == 4:
            fig, axs = plt.subplots(2, 2, figsize=(10, 10), dpi=75)
            plt.subplots_adjust(wspace=0.5, hspace=0.5)
            axs = [axs[0][0], axs[0][1], axs[1][0], axs[1][1]]

        for ii, iq in enumerate(data['data']['iq_list']):
            axs[ii].plot(iq[0], '.', label="I value, ADC %d" % (data['config']['ro_chs'][ii]))
            axs[ii].plot(iq[1], '.', label="Q value, ADC %d" % (data['config']['ro_chs'][ii]))
            axs[ii].plot(np.abs(iq[0] + 1j * iq[1]), '.', label="mag, ADC %d" % (data['config']['ro_chs'][ii]))
            axs[ii].set_ylabel("a.u.")
            axs[ii].set_xlabel("Clock ticks")
            axs[ii].legend(loc='best', bbox_to_anchor=(1, 1))
            axs[ii].axhline(32768, linestyle='--', color='k')
            axs[ii].axhline(-32768, linestyle='--', color='k')
        axs[0].set_title("Averages = " + str(data['config']["soft_avgs"]))
        plt.savefig(self.iname + '_decimated.png', bbox_inches='tight')
        plt.show()
