import random

from socProxy import makeProxy
import matplotlib.pyplot as plt
import numpy as np
from qick.helpers import gauss
from Experiment import ExperimentClass
import datetime
from qick import *
import time
from scipy.optimize import curve_fit
from tqdm.notebook import tqdm
import pickle
import os
import warnings
import PythonDrivers.readTempLog as tempLog
import Pyro4.util


# ============================================= #
# Russell McLellan, supported by Sara Sussman and Sho Uemura
# Initial working version August 16, 2022
#
# Purpose of this program is to emulate a VNA-style frequency sweep with the RFSOC using up to four tones for faster
# averaging. Two forms of averaging are used, 'reps' and 'rounds'. Reps are repeated measurements without changing the
# frequency. Rounds are repeats of the spectrum. Note that reps are coherent averages of I and Q, while rounds average
# amplitudes only
#
# There are two classes in this file:
# ResSweepProgram - created and handled by ResSweep. This class directly interfaces with the RFSOC firmware
# ResSweep - created and handled by the user in another folder. Repackages data for ResSweepProgram, creates
#            preliminary fits, saves data, and loops through frequency points
#
# ============================================= #


class ResSweepProgram(AveragerProgram):
    def __init__(self, soccfg, cfg):
        # inputs:
        #       - cfg - python dictionary generated by ResSweep class
        #       - soccfg - object referencing the RFSOC
        super().__init__(soccfg, cfg)

    # initialize is run once when ResSweep calls ResSweepProgram.acquire
    def initialize(self):
        cfg = self.cfg

        # set the nyquist zone
        for i in cfg['res_ch']:
            self.declare_gen(ch=i, nqz=2)

        for i, ch in enumerate(cfg["ro_chs"]):
            freq = self.freq2reg(cfg["pulse_freqs"][i],gen_ch=cfg["res_ch"][i],
                                 ro_ch=ch)
            phase = self.deg2reg(cfg["res_phases"][i],
                                 gen_ch=cfg["res_ch"][i])
            self.declare_readout(ch=ch, length=self.cfg["readout_length"],
                                 freq=self.cfg["pulse_freqs"][i],
                                 gen_ch=cfg["res_ch"][i])
            self.default_pulse_registers(ch=cfg['res_ch'][i],
                                         freq=freq,
                                         phase=phase,
                                         gain=cfg["pulse_gains"][i],
                                         mode='periodic',
                                         stdysel='last')
            self.set_pulse_registers(ch=cfg["res_ch"][i], style='const',
                                     length=1000)

        # play tone constantly
        self.synci(200)  # give processor some time to configure pulses
        for i, res_ch in enumerate(self.cfg['res_ch']):
            self.pulse(ch=self.cfg["res_ch"][i])
        self.sync_all(cfg["ring_time"])  # play for ring_time

    # body is run for cfg['reps'] number of times when ResSweep calls ResSweepProgram.acquire
    def body(self):
        # read data
        for i, res_ch in enumerate(self.cfg['res_ch']):
            self.trigger(adcs=[self.cfg['ro_chs'][i]], pins=[0],
                            adc_trig_offset=self.cfg['adc_trig_offset'])  # trigger the adc acquisition
        # sync everything
        self.wait_all()
        self.sync_all(t=self.cfg['adc_trig_offset'])

# ====================================================== #


class ResSweep(ExperimentClass):
    # this is the class that the user will interact with to take measurements
    # Two dictionaries are used throughout the class, 'input' and 'cfg'. 'Input' is entirely user defined, uses units
    # of us for time and MHz for frequency, and is not changed in any function. 'cfg' is generated by the class, uses
    # units of clock ticks for time and MHz for frequency, and is changed.
    # 'Input' is designed to be human readable, 'cfg' is for the class to interpret
    def __init__(self, inputDict=None, soc=None, soccfg=None, path='', prefix='data', config_file=None, progress=None,
                 temperatureLogPath='Z:/t1Team/logFiles/'):
        # inputs:
        #       - inputDict - Python dictionary defined by the user with fields defined
        #       - soc, soccfg - objects referring to the RFSOC proxy server
        #       - path - string specifying the path where the results will be saved
        #       - prefix - prefix attached to the beginning of the filename
        #       - tempreatureLogPath - str specifying the temperature log file that will be read for the measurement temperature
        super().__init__(soc=soc, soccfg=soccfg, path=path, prefix=prefix, cfg=None, config_file=config_file, progress=progress)

        # This value is a workaround for a problem with multiplexed readout. From Sho on Aug 12, 2022, both I and Q are
        # centered around -0.5 instead of 0. self.IQoffset is added to both I and Q as they are read to compensate.
        # This workaround should be removed when the RFSOC is patched
        # self.IQoffset = 0.5
        self.IQoffset = 0

        self.soc = soc
        if len(inputDict['res_f']) == 1:
            self.cfg = {"res_ch": [0],
                        "ro_chs": [0],
                        "res_phases": [0]
                        }
        elif len(inputDict['res_f']) == 2:
            self.cfg = {"res_ch": [0,1],
                        "ro_chs": [0,1],
                        "res_phases": [0,0]
                        }
        else:
            print('Error: ony one or two res_fs can be specified')
            assert 1

        # save frequency parameters into class variables for later use
        self.LO_f = inputDict['LO_f']
        self.span_f = inputDict['span_f']
        self.res_f = inputDict['res_f']

        # save number parameters for later use
        self.n_expts = inputDict['n_expts']
        self.n_rounds = inputDict['n_rounds']
        self.n_reps = inputDict['n_reps']

        # convert timing parameter for later use
        self.ring_up_time = soc.us2cycles(inputDict['ring_up_time'])  # generator units. Used to set the initial pulse time
        self.ring_between_time = soc.us2cycles(inputDict['ring_between_time']) # generator units. Used to set the pulse time between frequency poits
        self.cfg['readout_length'] = soc.us2cycles(inputDict['readout_length'], ro_ch=0)  # adc units. used to set the length of the readout foe each rep
        self.cfg['adc_trig_offset'] = soc.us2cycles(inputDict['adc_trig_offset'])  # tProc units. Used to offset the read window from the start of each pulse in a rep

        # save power parameters for future use
        self.cfg["pulse_gains"] = inputDict['gain']

        self.pulseArray_f = [[] for i in self.cfg['ro_chs']]
        self.resArray_f = [[] for i in self.cfg['ro_chs']]
        # calculate frequencies to be swept
        for i in range(len(self.pulseArray_f)):
            self.pulseArray_f[i] = np.linspace(self.res_f[i] - self.LO_f - self.span_f[i] / 2, self.res_f[i] - self.LO_f + self.span_f[i]/2, self.n_expts)
            self.resArray_f[i] = self.pulseArray_f[i] + self.LO_f

        # store input for saving later
        self.inputDict = inputDict

        # algorithm to increment filenumbers
        self.filePrefix = prefix
        # filenames = os.listdir(self.path)
        # increment = 0
        # for file in filenames:
        #     if self.filePrefix + '_' in file:
        #         if '.' in file:
        #             dotInd = file.index('.')
        #         else:
        #             dotInd = 0
        #     try:
        #         newIncrement = int(file[(dotInd - 3):dotInd])
        #         if newIncrement > increment:
        #             increment = newIncrement
        #     except:
        #         pass
        # increment += 1
        datestr = datetime.datetime.now().strftime("%Y-%m-%d-%H-%M-%S")
        self.filename = self.filePrefix + '-' + datestr
        self.temperatureLogPath = temperatureLogPath
        self.readTemp()  # initial read to raise a warning if the file is out of date

        print('Frequencies out are: {0} MHz'.format([res_f-self.LO_f for res_f in self.res_f]))

    # used for preliminary fits
    def hangerFit(self, xData, freq0, QInt, Qc, asymm, offset):
        Q0 = 1 / ((1 / QInt) + (1 / Qc))
        return 20 * np.log10(np.abs(1 - ((Q0 / Qc) - 2j * Q0 * asymm / (2 * np.pi * freq0)) / (
                    1 + 2j * Q0 * (xData - freq0) / freq0))) + offset

    # function to perform a frequency sweep
    def acquire(self, progress=False):
        diList = [[] for i in range(self.n_expts)]
        dqList = [[] for i in range(self.n_expts)]
        IArray = [np.asarray([0. for ii in range(self.n_expts)]) for i in self.res_f]
        QArray = [np.asarray([0. for ii in range(self.n_expts)]) for i in self.res_f]

        start = time.time()
        for roundInd in tqdm(range(self.n_rounds)):
            roundStart = time.time()

            # ring up the resonator
            self.cfg['ring_time'] = self.ring_up_time
            self.cfg['pulse_freqs'] = [freq[0] for freq in self.pulseArray_f]
            self.cfg['reps'] = 2
            prog = ResSweepProgram(self.soccfg, self.cfg)
            try:
                dummy = prog.acquire(self.soc, load_pulses=True) # we throw out the data we collect during ring up
            except Exception:
                print("Pyro traceback:")
                print("".join(Pyro4.util.getPyroTraceback()))

            # acquire sweeps of data
            self.cfg['reps'] = self.n_reps
            self.cfg['ring_time'] = self.ring_between_time
            for fInd in range(self.n_expts):
                self.cfg['pulse_freqs'] = [pulse_f[fInd] for pulse_f in self.pulseArray_f]
                # if fInd % 50 == 0:
                #     print('{0}: {1:0.2f} s'.format(fInd, time.time() - roundStart))
                # freqStart = time.time()
                prog = ResSweepProgram(self.soccfg, self.cfg)

                try:
                    iqList = prog.acquire(self.soc, load_pulses=True)
                except Exception:
                    print("Pyro traceback:")
                    print("".join(Pyro4.util.getPyroTraceback()))

                for res in range(len(self.res_f)):
                    IArray[res][fInd] += iqList[0][res][0]
                    QArray[res][fInd] += iqList[1][res][0]

        print('Final time = {0:0.3f} s'.format(time.time() - start))

        # normalize measurements and find amplitudes
        for i in range(len(self.res_f)):
            IArray[i] = IArray[i] / self.n_rounds
            QArray[i] = QArray[i] / self.n_rounds

        ampArray = [np.abs(IArray[i] + 1j*QArray[i]) for i in range(len(self.res_f))]
        ampArray_log = [20*np.log10(ampArray[i]) for i in range(len(self.res_f))]
        # phaseArray = [np.angle(IArray[i] + 1j*QArray[i]) for i in range(len(self.res_f))]
        phaseArray = [np.arctan2(QArray[i],IArray[i]) for i in range(len(self.res_f))]

        data={'config': self.cfg,
              'inputDict': self.inputDict,
              'data': {
                  'ampArray': ampArray,
                  'ampArray_log': ampArray_log,
                  'phaseArray': phaseArray,
                  'IArray': IArray,
                  'QArray': QArray,
                  'f': self.resArray_f,
                  'power': self.inputDict['power'],
                  # 'diList': diList,
                  # 'dqList': dqList,
                  'endTime': time.time(),
                  'startTime': start,
                  'temperature_mK': self.readTemp()
              }}
        


        #update saved object, have to update read in code to match
        # acquisition_params = {
        #     'LO_freq': self.inputDict['LO_f'],
        #     'base_powers': self.inputDict['base_powers'] ,
        #     'powers': self.inputDict['powers'],
        #     'res_chs': self.cfg['res_ch'],
        #     'ro_chs': self.cfg['ro_chs'],
        #     'res_phases': self.cfg['res_phases'],
        #     'readout_length_cycles_us': [self.cfg['readout_length'],self.inputDict['readout_length']],
        #     'adc_trig_offset_cycles_us': [self.cfg['adc_trig_offset'],self.inputDict['adc_trig_offset']],
        #     'ring_up_time_cycles_us': [self.ring_up_time,self.inputDict['ring_up_time']],
        #     'ring_between_time_cycles_us': [self.ring_between_time, self.inputDict['ring_between_time']],
        #     'gains': self.inputDict['gain'],
        #     'freqs': self.inputDict['res_f'],
        #     'spans': self.inputDict['span_f'],
        #     'save_path': self.inputDict['save_path'],
        #     'n_rounds': self.inputDict['n_rounds'],
        #     'n_expts': self.inputDict['n_expts'],
        #     'n_res': self.inputDict['n_res'],
        #     'n_reps': self.inputDict['n_reps'],
        #     'names' : self.inputDict['names']
        # }

        # data = {'acquisition_params': acquisition_params,
        #         'data': {
        #           'ampArray': ampArray,
        #           'ampArray_log': ampArray_log,
        #           'phaseArray': phaseArray,
        #           'IArray': IArray,
        #           'QArray': QArray,
        #           'f': self.resArray_f,
        #           'endTime': time.time(),
        #           'startTime': start,
        #           'temperature_mK': self.readTemp()
        #         }}

        self.data=data

        return data

    # this function finds the last edited log file and reads the last temperature from it. It will throw a warning if
    # the temperature is more than 30 minutes out of date
    def readTemp(self):
        latest_edited_file = max([f for f in os.scandir(self.temperatureLogPath) if 'Temps_automatedControl.txt' in f.name],
                                 key=lambda x: x.stat().st_mtime).name
        logTime, logTemp = tempLog.readTempLog(self.temperatureLogPath + '/' + latest_edited_file)
        minutesOld = (datetime.datetime.now() - logTime).total_seconds() / 60
        if minutesOld > 30:
            warnings.warn(
                'Temperature log is {0:0.01f} minutes out of date. Make sure you are outputting the log file from the temperature PC'.format(
                    minutesOld))

        return logTemp

    # call this function after acquire to plot the results with a preliminary fit
    def display(self, data=None, fit=True, **kwargs):
        if data == None:
            data = self.data
        data = data['data']

        pOpt = [[] for i in self.res_f]
        pCov = [[] for i in self.res_f]
        for i in range(len(self.cfg['ro_chs'])):

            if fit:
                # generate good initial guesses
                centerF = self.resArray_f[i][data['ampArray_log'][i].argmin()]
                offset = np.max(data['ampArray_log'][i])
                yMid = np.min(data['ampArray_log'][i])+(np.max(data['ampArray_log'][i]) + np.min(data['ampArray_log'][i]))/2
                nBelow = 0
                for y in data['ampArray_log'][i]:
                    if y < yMid:
                        nBelow += 1
                # print('nbelow',nBelow)
                # print('df',self.resArray_f[i][1]-self.resArray_f[i][0])
                # bandwidth = nBelow * (self.resArray_f[i][1]-self.resArray_f[i][0])
                # Q_approx = centerF/bandwidth
                Q_approx=1e6
                # print(Q_approx,centerF)
                # fit data
                # if Q_approx==np.inf:
                #     Q_approx=1e6
                pOpt[i], pCov[i] = curve_fit(self.hangerFit, (self.resArray_f[i]) * 10 ** 6, data['ampArray_log'][i],
                                             p0=[(centerF) * 10 ** 6, Q_approx, Q_approx, 0, offset], maxfev=100000)
                pOpt[i][1] = abs(pOpt[i][1])
                pOpt[i][2] = abs(pOpt[i][2])

        if len(self.cfg['ro_chs']) == 1:
            fig, axs = plt.subplots(1, 1, figsize=(4.5, 4.5), dpi=75)
            plt.subplots_adjust(wspace=0.5, hspace=0.5)
            axs = [axs]
        elif len(self.cfg['ro_chs']) == 2:
            fig, axs = plt.subplots(1, 2, figsize=(10, 4.5), dpi=75)
            plt.subplots_adjust(wspace=0.5, hspace=0.5)
        elif len(self.cfg['ro_chs']) == 3:
            fig, axs = plt.subplots(2, 2, figsize=(10, 10), dpi=75)
            plt.subplots_adjust(wspace=0.5, hspace=0.5)
            axs[1][1].set_axis_off()
            axs[1][1].set_frame_on(False)
            axs = [axs[0][0], axs[0][1], axs[1][0]]
        elif len(self.cfg['ro_chs']) == 4:
            fig, axs = plt.subplots(2, 2, figsize=(10, 10), dpi=75)
            plt.subplots_adjust(wspace=0.5, hspace=0.5)
            axs = [axs[0][0], axs[0][1], axs[1][0], axs[1][1]]

        for i in range(len(self.cfg['ro_chs'])):
            axs[i].plot(self.resArray_f[i], data['ampArray_log'][i], '.', label='data', markersize=2)
            if fit:
                axs[i].plot(self.resArray_f[i], self.hangerFit((self.resArray_f[i]) * 10 ** 6, *pOpt[i]), label='fit')
            axs[i].set_ylabel('20log10(I^2 + Q^2)')
            axs[i].set_xlabel('Frequency [MHz]')
            axs[i].legend(loc='best')
            if fit:
                axs[i].set_title('f = {0:.0f} MHz, Q_int = {1:0.4e}'.format(self.res_f[i], pOpt[i][1]))
            else:
                axs[i].set_title('f = {0:.0f} MHz'.format(self.res_f[i]))
            axs[i].grid()

        plt.savefig(self.path+'/'+self.filename+'_sweep.png', bbox_inches='tight')
        plt.show()

        return pOpt, pCov

    # call this function after acquire to save the data
    def save_data(self, data=None):
        print(f'Saving {self.filename}')
        with open(self.path+'/'+self.filename+'.pickle', 'wb') as f:
            pickle.dump(self.data, f)
        # super().save_data(data=data['data'])

    def acquire_decimated(self, soft_avgs=1, readout_length=100, progress=False):

        self.cfg['ring_time'] = self.ring_up_time
        self.cfg['soft_avgs'] = soft_avgs
        self.cfg['readout_length'] = readout_length
        self.cfg['reps'] = 1
        self.cfg['pulse_freqs'] = [np.mean(freqs) for freqs in self.pulseArray_f]

        prog = ResSweepProgram(self.soccfg, self.cfg)
        print("start decimated")
        self.soc.reset_gens()  # clear any DC or periodic values on generators
        iq_list = prog.acquire_decimated(self.soc, load_pulses=True, progress=False)
        print("decimated done")
        data = {'config': self.cfg, 'data': {'iq_list': iq_list}}
        self.data = data
        return data

    def display_decimated(self, data=None, fit=True, **kwargs):
        if data is None:
            data = self.data

        if len(self.cfg['ro_chs']) == 1:
            fig, axs = plt.subplots(1, 1, figsize=(4.5, 4.5), dpi=75)
            axs = [axs]
            plt.subplots_adjust(wspace=0.5, hspace=0.5)
        elif len(self.cfg['ro_chs']) == 2:
            fig, axs = plt.subplots(2, 1, figsize=(4.5, 10), dpi=75)
            plt.subplots_adjust(wspace=0.5, hspace=0.5)
        elif len(self.cfg['ro_chs']) == 3:
            fig, axs = plt.subplots(2, 2, figsize=(10, 10), dpi=75)
            plt.subplots_adjust(wspace=0.5, hspace=0.5)
            axs[1][1].set_axis_off()
            axs[1][1].set_frame_on(False)
            axs = [axs[0][0], axs[0][1], axs[1][0]]
        elif len(self.cfg['ro_chs']) == 4:
            fig, axs = plt.subplots(2, 2, figsize=(10, 10), dpi=75)
            plt.subplots_adjust(wspace=0.5, hspace=0.5)
            axs = [axs[0][0], axs[0][1], axs[1][0], axs[1][1]]

        for ii, iq in enumerate(data['data']['iq_list']):
            axs[ii].plot(iq[0], '.', label="I value, ADC %d" % (data['config']['ro_chs'][ii]))
            axs[ii].plot(iq[1], '.', label="Q value, ADC %d" % (data['config']['ro_chs'][ii]))
            axs[ii].plot(np.abs(iq[0] + 1j * iq[1]), '.', label="mag, ADC %d" % (data['config']['ro_chs'][ii]))
            axs[ii].set_ylabel("a.u.")
            axs[ii].set_xlabel("Clock ticks")
            axs[ii].legend(loc='best', bbox_to_anchor=(1, 1))
            axs[ii].axhline(32768, linestyle='--', color='k')
            axs[ii].axhline(-32768, linestyle='--', color='k')
        axs[0].set_title("Averages = " + str(data['config']["soft_avgs"]))
        plt.savefig(self.iname + '_decimated.png', bbox_inches='tight')
        plt.show()
